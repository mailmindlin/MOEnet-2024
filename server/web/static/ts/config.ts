/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Allow remote changes to overwrite this config?
 */
export type AllowOverwrite = boolean;
/**
 * NetworkTables data
 */
export type NetworkTables = NetworkTablesConfig;
/**
 * Should anything be sent to NetworkTables?
 */
export type Enabled = boolean;
/**
 * FRC team number
 */
export type Team = number;
/**
 * Which port should we connect to?
 */
export type Port = number;
/**
 * NetworkTables host IP
 */
export type Host = string | null;
/**
 * Client connection name
 */
export type ClientId = string;
/**
 * Root table name
 */
export type Table = string;
/**
 * Minimum level to send logs
 */
export type LogLevel = string;
/**
 * Number of log lines to retain
 */
export type LogLines = number;
/**
 * Should we listen for sleep control at `/moenet/rio_request_sleep`?
 */
export type Subscribesleep = boolean;
/**
 * Should we listen for config updates at `/moenet/rio_dynamic_config`?
 */
export type Subscribeconfig = boolean;
/**
 * Should we publish logs to `/moenet/client_log`?
 */
export type Publishlog = boolean;
/**
 * Should we publish ping updates to `/moenet/client_ping`?
 */
export type Publishping = boolean;
/**
 * Should we publish errors updates to `/moenet/client_error`?
 */
export type Publisherrors = boolean;
export type Publishstatus = boolean;
/**
 * Should we publish this config to `/moenet/client_config`?
 */
export type Publishconfig = boolean;
/**
 * Should we publish system info to `/moenet/client_telemetry`?
 */
export type Publishsysteminfo = boolean;
/**
 * Publish object detections to `/moenet/client_detections`
 */
export type Publishdetections = boolean;
/**
 * Which direction to send data?
 */
export type NetworkTablesDirection = "sub" | "pub" | false;
/**
 * Allow the Rio to override poses
 */
export type Subscribeposeoverride = boolean;
/**
 * Publish Field2d widget (field->odom)
 */
export type Publishfield2Df2O = boolean;
/**
 * Publish Field2d widget (field->robot)
 */
export type Publishfield2Df2R = boolean;
/**
 * Publish Field2d widget (field->notes)
 */
export type Publishfield2Ddets = boolean;
/**
 * Timer for synchronizing with RoboRIO
 */
export type Timer = "system" | NavXConfig;
/**
 * NavX connection
 */
export type Port1 = "usb" | "usb1" | "usb2";
/**
 * NavX poll rate (in hertz)
 */
export type UpdateRate = number;
export type Level = "DEBUG" | "INFO" | "WARN" | "ERROR" | "FATAL";
export type File = string | null;
export type Format = string;
export type Datefmt = string | null;
export type Formatter = string | LogFormatterSpec | null;
export type Handlers1 = (string | LogHandlerSpec)[];
export type Enabled1 = boolean;
export type Folder = string | null;
/**
 * Make log folder if it doesn't exist?
 */
export type Mkdir = boolean;
/**
 * Should we clean up old log files? (see free_space and max_logs)
 */
export type Cleanup = boolean;
/**
 * Minimum free size before we don't make more logs/clean up old ones
 */
export type FreeSpace = number | null;
/**
 * Maximum number of log files to retain (requires cleanup)
 */
export type MaxLogs = number | null;
/**
 * Number of times to have seen an object before accepting it
 */
export type MinDetections = number;
/**
 * Length of time to keep an object detecting (seconds)
 */
export type DetectedDuration = string;
/**
 * Length of time to retain an object detection (seconds)
 */
export type HistoryDuration = string;
export type ClusteringDistance = number;
export type MinDepth = number;
export type Alpha = number;
/**
 * Length of pose replay buffer (seconds)
 */
export type History = string;
/**
 * Should we force the pose to fit on the field?
 */
export type Force2D = boolean;
/**
 * How should we handle AprilTag detections?
 */
export type AprilTagStrategy = "lowest_ambiguity" | "closest_to_last_pose" | "average_best_targets";
export type Odometrystddevs = number[];
/**
 * Pick the n-th camera found (unstable, starts at 1)
 */
export type Ordinal = number | null;
/**
 * Filter camera by mxid
 */
export type Mxid = string | null;
/**
 * Filter camera by device name
 */
export type Devname = string | null;
export type Platform = "X_LINK_ANY_PLATFORM" | "X_LINK_MYRIAD_2" | "X_LINK_MYRIAD_X" | null;
export type Protocol =
  | "X_LINK_ANY_PROTOCOL"
  | "X_LINK_IPC"
  | "X_LINK_NMB_OF_PROTOCOLS"
  | "X_LINK_PCIE"
  | "X_LINK_TCP_IP"
  | "X_LINK_USB_CDC"
  | "X_LINK_USB_VSC"
  | null;
/**
 * ID to reference this definition by
 */
export type Id = string;
export type Name = string | null;
/**
 * Robot-to-camera transform
 */
export type Pose = {
  translation: Translation;
  rotation: Rotation;
} | null;
export type X = number;
export type Y = number;
export type Z = number;
export type W = number;
export type X1 = number;
export type Y1 = number;
export type Z1 = number;
/**
 * If this camera can move, this is it's network name
 */
export type DynamicPose = string | null;
export type CameraSelectors = CameraSelectorDefinition[];
/**
 * Human-readable name
 */
export type Name1 = string | null;
/**
 * Which camera are we referencing?
 */
export type Selector = string | OakSelector;
/**
 * Pick the n-th camera found (unstable, starts at 1)
 */
export type Ordinal1 = number | null;
/**
 * Filter camera by mxid
 */
export type Mxid1 = string | null;
/**
 * Filter camera by device name
 */
export type Devname1 = string | null;
export type Platform1 = "X_LINK_ANY_PLATFORM" | "X_LINK_MYRIAD_2" | "X_LINK_MYRIAD_X" | null;
export type Protocol1 =
  | "X_LINK_ANY_PROTOCOL"
  | "X_LINK_IPC"
  | "X_LINK_NMB_OF_PROTOCOLS"
  | "X_LINK_PCIE"
  | "X_LINK_TCP_IP"
  | "X_LINK_USB_CDC"
  | "X_LINK_USB_VSC"
  | null;
export type MaxUsb = ("FULL" | "HIGH" | "LOW" | "SUPER" | "SUPER_PLUS" | "UNKNOWN") | null;
/**
 * Is it an error if this camera is not detected?
 */
export type Optional = boolean;
export type ConnectionTries = number;
export type ConnectionDelay = string;
export type RestartTries = number;
/**
 * Camera pose (in robot-space)
 */
export type Pose1 = {
  translation: Translation1;
  rotation: Rotation1;
} | null;
export type X2 = number;
export type Y2 = number;
export type Z2 = number;
export type W1 = number;
export type X3 = number;
export type Y3 = number;
export type Z3 = number;
/**
 * If this camera can move, this is it's network name
 */
export type DynamicPose1 = string | null;
/**
 * Configure pipeline
 */
export type Pipeline = PipelineConfig | string | null;
/**
 * Stage name
 */
export type Stage = "inherit";
/**
 * Is this stage enabled?
 */
export type Enabled2 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional1 = boolean;
export type Id1 = string;
/**
 * Stage name
 */
export type Stage1 = "rgb";
/**
 * Is this stage enabled?
 */
export type Enabled3 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional2 = boolean;
export type ColorCameraProperties_SensorResolution =
  | "THE_1080_P"
  | "THE_1200_P"
  | "THE_4_K"
  | "THE_5_MP"
  | "THE_12_MP"
  | "THE_4000X3000"
  | "THE_13_MP"
  | "THE_5312X6000"
  | "THE_48_MP"
  | "THE_720_P"
  | "THE_800_P"
  | "THE_1440X1080"
  | "THE_1352X1012"
  | "THE_2024X1520";
/**
 * Max FPS
 */
export type Fps = number | null;
/**
 * Stage name
 */
export type Stage2 = "mono";
/**
 * Is this stage enabled?
 */
export type Enabled4 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional3 = boolean;
export type Target = "left" | "right";
export type MonoCameraProperties_SensorResolution =
  | "THE_720_P"
  | "THE_800_P"
  | "THE_400_P"
  | "THE_480_P"
  | "THE_1200_P";
/**
 * Max FPS
 */
export type Fps1 = number | null;
/**
 * Stage name
 */
export type Stage3 = "depth";
/**
 * Is this stage enabled?
 */
export type Enabled5 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional4 = boolean;
/**
 * Enable Left-Right check
 */
export type Checkleftright = boolean | null;
/**
 * Enable extended disparity mode
 */
export type Extendeddisparity = boolean | null;
/**
 * Set preset profile
 */
export type Preset = "high_accuracy" | "high_density" | null;
/**
 * Stage name
 */
export type Stage4 = "nn";
/**
 * Is this stage enabled?
 */
export type Enabled6 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional5 = boolean;
export type Config = NNConfig | string;
export type ConfidenceThreshold = number;
export type IouThreshold = number;
export type Labels = string[];
export type Depthlowerthreshold = number;
export type Depthupperthreshold = number;
export type Classes = number;
export type Coordinatesize = number;
export type Anchors = number[];
export type Blobpath = string;
/**
 * Stage name
 */
export type Stage5 = "apriltag";
/**
 * Is this stage enabled?
 */
export type Enabled7 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional6 = boolean;
export type Runtime = "device" | "host";
export type Camera = "left" | "right" | "rgb";
/**
 * How many threads should be used for computation
 */
export type DetectorThreads = number | null;
/**
 * Should we run the detector on a different thread? Only useful if we're doing multiple things with the same camera
 */
export type DetectorAsync = boolean;
/**
 * How much sharpening should be done to decoded images
 */
export type DecodeSharpening = number | null;
export type Quaddecimate = number;
export type Quadsigma = number;
export type RefineEdges = boolean;
/**
 * Maximum number of bits to correct
 */
export type HammingDistance = number;
export type DecisionMargin = number;
export type Numiterations = number;
/**
 * Should we try to undistort the camera lens?
 */
export type Undistort = boolean;
export type SolvePnP = boolean;
export type DoMultiTarget = boolean;
export type DoSingleTargetAlways = boolean;
export type Apriltags =
  | (AprilTagFieldRefWpi | AprilTagFieldRefSai)
  | (AprilTagFieldInlineWpi | AprilTagFieldInlineSai)
  | AprilTagFieldNamedWpilib;
export type Format1 = "wpi";
/**
 * Path to AprilTag configuration
 */
export type Path = string;
export type AprilTagFamily = "tag16h5" | "tag25h9" | "tag36h10" | "tag36h11" | "tagCircle21h7" | "tagStandard41h12";
/**
 * AprilTag side length, in meters
 */
export type Tagsize = number;
export type Format2 = "sai";
/**
 * Path to AprilTag configuration
 */
export type Path1 = string;
/**
 * Field length (meters)
 */
export type Length = number;
/**
 * Field width (meters)
 */
export type Width = number;
export type Format3 = "wpi";
/**
 * AprilTag id
 */
export type Id2 = number;
export type X4 = number;
export type Y4 = number;
export type Z4 = number;
export type W2 = number;
export type X5 = number;
export type Y5 = number;
export type Z5 = number;
/**
 * AprilTags (WPI format)
 */
export type Tags = AprilTagWpi[];
/**
 * AprilTag side length, in meters
 */
export type Tagsize1 = number;
export type Format4 = "sai";
/**
 * AprilTag id
 */
export type Id3 = number;
/**
 * Tag size (meters)
 */
export type Size = number;
/**
 * @minItems 4
 * @maxItems 4
 */
export type Mat44 = [unknown, unknown, unknown, unknown];
/**
 * AprilTags (SAI format)
 */
export type Tags1 = AprilTagSai[];
/**
 * Named AprilTag field
 */
export type AprilTagFieldNamedWpilib = "2022RapidReact" | "2023ChargedUp" | "2024Crescendo";
/**
 * Stage name
 */
export type Stage6 = "slam";
/**
 * Is this stage enabled?
 */
export type Enabled8 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional7 = boolean;
export type Slam = boolean;
/**
 * Enable VIO
 */
export type Vio = boolean;
export type MapSave = string | null;
export type MapLoad = string | null;
/**
 * Wait for external pose before emitting data
 */
export type Waitforpose = boolean;
export type Apriltags1 =
  | (AprilTagFieldRefWpi | AprilTagFieldRefSai)
  | (AprilTagFieldInlineWpi | AprilTagFieldInlineSai)
  | null;
/**
 * Stage name
 */
export type Stage7 = "web";
/**
 * Is this stage enabled?
 */
export type Enabled9 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional8 = boolean;
/**
 * Name of video stream for user consumption
 */
export type VideoDisplayTarget = "left" | "right" | "rgb" | "depth";
/**
 * Maximum framerate for stream
 */
export type Maxframerate = number | null;
/**
 * Stage name
 */
export type Stage8 = "save";
/**
 * Is this stage enabled?
 */
export type Enabled10 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional9 = boolean;
export type Path2 = string;
/**
 * Maximum framerate for stream
 */
export type Maxframerate1 = number | null;
/**
 * Stage name
 */
export type Stage9 = "show";
/**
 * Is this stage enabled?
 */
export type Enabled11 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional10 = boolean;
/**
 * Stage name
 */
export type Stage10 = "imu";
/**
 * Is this stage enabled?
 */
export type Enabled12 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional11 = boolean;
/**
 * Stage name
 */
export type Stage11 = "telemetry";
/**
 * Is this stage enabled?
 */
export type Enabled13 = boolean;
/**
 * If there's an error constructing this stage, is that a pipeline failure?
 */
export type Optional12 = boolean;
export type PipelineConfig = (
  | InheritStageConfig
  | ColorCameraStageConfig
  | MonoCameraStageConfig
  | StereoDepthStageConfig
  | ObjectDetectionStageConfig
  | AprilTagStageConfig
  | SlamStageConfig
  | WebStreamStageConfig
  | SaveStageConfig
  | ShowStageConfig
  | ImuStageConfig
  | TelemetryStageConfig
)[];
/**
 * Configuration for individual cameras
 */
export type Cameras = CameraConfig[];
export type Id4 = string;
/**
 * Reusable pipelines
 */
export type Pipelines = PipelineDefinition[];
/**
 * Should we enable the webserver?
 */
export type Enabled14 = boolean;
/**
 * Host for HTTP server
 */
export type Host1 = string | null;
/**
 * Port for HTTP server
 */
export type Port2 = number | null;
/**
 * Force a specific video codec (e.g. video/H264)
 */
export type VideoCodec = string | null;
/**
 * SSL certificate file (for HTTPS)
 */
export type CertFile = string | null;
/**
 * SSL key file (for HTTPS)
 */
export type KeyFile = string | null;

/**
 * Local config data
 */
export interface LocalConfig {
  allow_overwrite?: AllowOverwrite;
  nt?: NetworkTables;
  timer?: Timer;
  log?: LogConfig;
  datalog?: DataLogConfig;
  estimator?: EstimatorConfig;
  camera_selectors?: CameraSelectors;
  cameras?: Cameras;
  pipelines?: Pipelines;
  web?: WebConfig;
}
/**
 * Configure NetworkTables. Must be provided locally
 */
export interface NetworkTablesConfig {
  enabled?: Enabled;
  team?: Team;
  port?: Port;
  host?: Host;
  client_id?: ClientId;
  table?: Table;
  log_level?: LogLevel;
  log_lines?: LogLines;
  subscribeSleep?: Subscribesleep;
  subscribeConfig?: Subscribeconfig;
  publishLog?: Publishlog;
  publishPing?: Publishping;
  publishErrors?: Publisherrors;
  publishStatus?: Publishstatus;
  publishConfig?: Publishconfig;
  publishSystemInfo?: Publishsysteminfo;
  publishDetections?: Publishdetections;
  /**
   * field -> robot transform (absolute pose)
   */
  tfFieldToRobot?: NetworkTablesDirection & string;
  /**
   * field -> odom transform (odometry estimate)
   */
  tfFieldToOdom?: NetworkTablesDirection & string;
  /**
   * odom->robot transform (odometry correction)
   */
  tfOdomToRobot?: NetworkTablesDirection & string;
  subscribePoseOverride?: Subscribeposeoverride;
  publishField2dF2O?: Publishfield2Df2O;
  publishField2dF2R?: Publishfield2Df2R;
  publishField2dDets?: Publishfield2Ddets;
}
/**
 * NavX configuration
 */
export interface NavXConfig {
  port?: Port1;
  update_rate?: UpdateRate;
}
/**
 * Configuration for logging output
 */
export interface LogConfig {
  level?: Level;
  file?: File;
  formatters?: Formatters;
  handlers?: Handlers;
  loggers?: Loggers;
}
export interface Formatters {
  [k: string]: LogFormatterSpec;
}
export interface LogFormatterSpec {
  format: Format;
  datefmt?: Datefmt;
}
export interface Handlers {
  [k: string]: LogHandlerSpec;
}
export interface LogHandlerSpec {
  formatter?: Formatter;
}
export interface Loggers {
  [k: string]: LoggerSpec;
}
export interface LoggerSpec {
  handlers?: Handlers1;
}
/**
 * Configuration for datalog
 */
export interface DataLogConfig {
  enabled?: Enabled1;
  folder?: Folder;
  mkdir?: Mkdir;
  cleanup?: Cleanup;
  free_space?: FreeSpace;
  max_logs?: MaxLogs;
}
export interface EstimatorConfig {
  detections?: ObjectTrackerConfig;
  pose?: PoseEstimatorConfig;
}
/**
 * Configuration for tracking object detections over time
 */
export interface ObjectTrackerConfig {
  min_detections?: MinDetections;
  detected_duration?: DetectedDuration;
  history_duration?: HistoryDuration;
  clustering_distance?: ClusteringDistance;
  min_depth?: MinDepth;
  alpha?: Alpha;
}
export interface PoseEstimatorConfig {
  history?: History;
  force2d?: Force2D;
  apriltagStrategy?: AprilTagStrategy | null;
  odometryStdDevs?: Odometrystddevs;
}
/**
 * Define a camera selector
 */
export interface CameraSelectorDefinition {
  ordinal?: Ordinal;
  mxid?: Mxid;
  devname?: Devname;
  platform?: Platform;
  protocol?: Protocol;
  id: Id;
  name?: Name;
  pose?: Pose;
  dynamic_pose?: DynamicPose;
}
export interface Translation {
  x: X;
  y: Y;
  z: Z;
}
export interface Rotation {
  quaternion: Quaternion;
}
export interface Quaternion {
  W: W;
  X: X1;
  Y: Y1;
  Z: Z1;
}
export interface CameraConfig {
  name?: Name1;
  selector: Selector;
  max_usb?: MaxUsb;
  retry?: RetryConfig;
  pose: Pose1;
  dynamic_pose?: DynamicPose1;
  pipeline?: Pipeline;
}
export interface OakSelector {
  ordinal?: Ordinal1;
  mxid?: Mxid1;
  devname?: Devname1;
  platform?: Platform1;
  protocol?: Protocol1;
}
/**
 * Configure restart/retry logic
 */
export interface RetryConfig {
  optional?: Optional;
  connection_tries?: ConnectionTries;
  connection_delay?: ConnectionDelay;
  restart_tries?: RestartTries;
}
export interface Translation1 {
  x: X2;
  y: Y2;
  z: Z2;
}
export interface Rotation1 {
  quaternion: Quaternion1;
}
export interface Quaternion1 {
  W: W1;
  X: X3;
  Y: Y3;
  Z: Z3;
}
/**
 * Include another defined pipeline
 */
export interface InheritStageConfig {
  stage?: Stage;
  enabled?: Enabled2;
  optional?: Optional1;
  id: Id1;
}
/**
 * Configure the RGB camera
 */
export interface ColorCameraStageConfig {
  stage?: Stage1;
  enabled?: Enabled3;
  optional?: Optional2;
  /**
   * Camera sensor resolution
   */
  resolution?: ColorCameraProperties_SensorResolution | null;
  fps?: Fps;
}
/**
 * Configure mono camera
 */
export interface MonoCameraStageConfig {
  stage?: Stage2;
  enabled?: Enabled4;
  optional?: Optional3;
  target: Target;
  /**
   * Camera sensor resolution
   */
  resolution?: MonoCameraProperties_SensorResolution | null;
  fps?: Fps1;
}
/**
 * Configure stereo depth
 */
export interface StereoDepthStageConfig {
  stage?: Stage3;
  enabled?: Enabled5;
  optional?: Optional4;
  checkLeftRight?: Checkleftright;
  extendedDisparity?: Extendeddisparity;
  preset?: Preset;
}
export interface ObjectDetectionStageConfig {
  stage?: Stage4;
  enabled?: Enabled6;
  optional?: Optional5;
  config: Config;
  blobPath: Blobpath;
}
/**
 * Base config for NN
 */
export interface NNConfig {
  confidence_threshold: ConfidenceThreshold;
  iou_threshold: IouThreshold;
  labels: Labels;
  depthLowerThreshold: Depthlowerthreshold;
  depthUpperThreshold: Depthupperthreshold;
  classes: Classes;
  coordinateSize: Coordinatesize;
  anchors: Anchors;
  anchor_masks: AnchorMasks;
}
export interface AnchorMasks {
  [k: string]: number[];
}
export interface AprilTagStageConfig {
  stage?: Stage5;
  enabled?: Enabled7;
  optional?: Optional6;
  runtime?: Runtime;
  camera?: Camera;
  detectorThreads?: DetectorThreads;
  detectorAsync?: DetectorAsync;
  decodeSharpening?: DecodeSharpening;
  quadDecimate?: Quaddecimate;
  quadSigma?: Quadsigma;
  refineEdges?: RefineEdges;
  hammingDist?: HammingDistance;
  decisionMargin?: DecisionMargin;
  numIterations?: Numiterations;
  undistort?: Undistort;
  solvePNP?: SolvePnP;
  doMultiTarget?: DoMultiTarget;
  doSingleTargetAlways?: DoSingleTargetAlways;
  apriltags: Apriltags;
}
/**
 * Reference to an AprilTag JSON file (in WPIlib format)
 */
export interface AprilTagFieldRefWpi {
  format?: Format1;
  path: Path;
  /**
   * AprilTag family
   */
  tagFamily: AprilTagFamily;
  tagSize: Tagsize;
}
/**
 * Reference to an AprilTag JSON file (in SpectacularAI format)
 */
export interface AprilTagFieldRefSai {
  format?: Format2;
  path: Path1;
  field: FieldLayout;
}
export interface FieldLayout {
  length: Length;
  width: Width;
}
/**
 * Inline AprilTag config (WPI format)
 */
export interface AprilTagFieldInlineWpi {
  format?: Format3;
  /**
   * Field size
   */
  field: FieldLayout;
  tags: Tags;
  /**
   * AprilTag family
   */
  tagFamily: AprilTagFamily;
  tagSize: Tagsize1;
}
/**
 * A single AprilTag definition (WPI format)
 */
export interface AprilTagWpi {
  ID: Id2;
  pose: Pose2;
}
/**
 * AprilTag pose, in field-space (field->tag)
 */
export interface Pose2 {
  translation: Translation2;
  rotation: Rotation2;
}
export interface Translation2 {
  x: X4;
  y: Y4;
  z: Z4;
}
export interface Rotation2 {
  quaternion: Quaternion2;
}
export interface Quaternion2 {
  W: W2;
  X: X5;
  Y: Y5;
  Z: Z5;
}
/**
 * Inline AprilTag config (SAI format)
 */
export interface AprilTagFieldInlineSai {
  format?: Format4;
  /**
   * Field size
   */
  field: FieldLayout;
  tags: Tags1;
}
export interface AprilTagSai {
  id: Id3;
  size: Size;
  /**
   * Tag family
   */
  family: AprilTagFamily;
  tagToWorld: Mat44;
}
/**
 * SAI slam
 */
export interface SlamStageConfig {
  stage?: Stage6;
  enabled?: Enabled8;
  optional?: Optional7;
  slam?: Slam;
  vio?: Vio;
  map_save?: MapSave;
  map_load?: MapLoad;
  waitForPose?: Waitforpose;
  apriltags?: Apriltags1;
}
/**
 * Stream data to web
 */
export interface WebStreamStageConfig {
  stage?: Stage7;
  enabled?: Enabled9;
  optional?: Optional8;
  target: VideoDisplayTarget;
  maxFramerate?: Maxframerate;
}
/**
 * Save images to file
 */
export interface SaveStageConfig {
  stage?: Stage8;
  enabled?: Enabled10;
  optional?: Optional9;
  target: VideoDisplayTarget;
  path: Path2;
  maxFramerate?: Maxframerate1;
}
/**
 * Show video stream as GUI
 */
export interface ShowStageConfig {
  stage?: Stage9;
  enabled?: Enabled11;
  optional?: Optional10;
  target: VideoDisplayTarget;
}
export interface ImuStageConfig {
  stage?: Stage10;
  enabled?: Enabled12;
  optional?: Optional11;
}
export interface TelemetryStageConfig {
  stage?: Stage11;
  enabled?: Enabled13;
  optional?: Optional12;
}
export interface PipelineDefinition {
  id: Id4;
  stages: PipelineConfig;
}
/**
 * Configure webserver
 */
export interface WebConfig {
  enabled?: Enabled14;
  host?: Host1;
  port?: Port2;
  video_codec?: VideoCodec;
  cert_file?: CertFile;
  key_file?: KeyFile;
}
